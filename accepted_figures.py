#!/usr/bin/env python
"""
Gutierrez, B.  Contains a function for finding the center of mass of 
fMRI image componants.  Also contains functions for overlaying 
a 2D fMRI image onto a 2D anatomical image in the axial, sagital, and cortial
plane
"""

"""
The threshold can be set to any positive number that controls how much of the overlay is seen.  Alpha 
is the blending of the image, i.e the transparency of the overlay and can be anythng from 0-1.
anat_hdr and overlay_hdr contain the header information from the datasets above
"""
import matplotlib.pyplot as plt
import nibabel as ni
import numpy as np
from matplotlib import gridspec
import ipdb


"""
Accepts the path to three datasets.  The first used in meica.py
as the anatomical is a 3D array from a NIFTI file, the second from the selection of output files from meica (i.e medn, mefc, mefl, tsoc)
the last is also generated by meica.py and is contained in the TED directory containing zscores for the voxels.
 is a 4d array.  Returns the data from the two argument datasets, the header of the two argument datasets,
an array called component (which contains the center of mass for each component) and a threshold map.
"""
def montage(maps, accept, threshold, alpha, series ='', Axial = 0, Sagital = 0, Coronal = 0):
	anat = maps[0]
	overlay = maps[1]
	threshold_data = maps[2]
	anat_hdr = maps[3]
	overlay_hdr = maps[4]
	l = 0
	n = np.array(range(1,10,1))*.1  # n is used to determine which anatomical slice to use
	ax_extreme = np.zeros(8)
	ax = ['x','y']
	cor_extreme = np.zeros(8)
	co = ['x','z']
	sag_extreme = np.zeros(8)
	sa = ['y','z']
	anat_x = mask(image = anat, axis = (1,2))
	anat_y = mask(image = anat, axis = (0,2))
	anat_z = mask(image = anat, axis = (0,1))
	for i in [0,1]:
		if Axial == 0:
			ax_extreme[i+6] = anat[:,:,anat.shape[2])/2.shape[i]*anat_hdr['srow_%s' % ax[i]][i] + anat_hdr['srow_%s' % ax[i]][3]#setting up talairach coordinates
			ax_extreme[i+4] = overlay.shape[i]*overlay_hdr['srow_%s' % ax[i]][i] + overlay_hdr['srow_%s' % ax[i]][3]
			ax_extreme[i+2] = anat_hdr['srow_%s' % ax[i]][3]
			ax_extreme[i] = overlay_hdr['srow_%s' % ax[i]][3]
		if Sagital == 0:
			sag_extreme[i+6] = anat[anat.shape[0]/2,:,:].shape[i]*anat_hdr['srow_%s' % sa[i]][i+1] + anat_hdr['srow_%s' % sa[i]][3]
			sag_extreme[i+4] = overlay.shape[i+1]*overlay_hdr['srow_%s' % sa[i]][i+1] + overlay_hdr['srow_%s' % sa[i]][3]
			sag_extreme[i+2] = anat_hdr['srow_%s' % sa[i]][3]
			sag_extreme[i] = overlay_hdr['srow_%s' % sa[i]][3]
		if Coronal == 0:
			cor_extreme[i+6] = anat[:,anat.shape[1]/2,:].shape[i]*anat_hdr['srow_%s' % co[i]][i*2] + anat_hdr['srow_%s' % co[i]][3]
			cor_extreme[i+4] = overlay.shape[i*2]*overlay_hdr['srow_%s' % co[i]][i*2] + overlay_hdr['srow_%s' % co[i]][3]
			cor_extreme[i+2] = anat_hdr['srow_%s' % co[i]][3]
			cor_extreme[i] = overlay_hdr['srow_%s' % co[i]][3]
	for i in range(overlay.shape[3]):
		if series == '':
			fig = plt.figure(figsize = (3.2*5,7-(Axial +Sagital)*2))
			gs0 = gridspec.GridSpec(6-(Axial + Sagital + Coronal)*2,18)
		else:
			fig = plt.figure(figsize = (3.2*5,7-(Axial +Sagital)*2+1))
			gs0 = gridspec.GridSpec(6-(Axial + Sagital + Coronal)*2+1,18)
		if i in accept:
			overlay[:,:,:,i] = np.absolute(overlay[:,:,:,i])
			overlay[abs(threshold_data[:,:,:,l]) < threshold,i] = np.nan
			for j in range(1,10):
				if Axial == 0:
					ax1 = fig.add_subplot(gs0[0:2,j*2:j*2+2])
					plt.imshow(anat[:,:,round(anat.shape[2]*n[j])].T, cmap = 'Greys_r', 
						origin = 'lower', interpolation = 'nearest', extent = [ax_extreme[2],ax_extreme[6],ax_extreme[3],ax_extreme[7]])
					plt.imshow(overlay[:,:,round(overlay.shape[2]*n[j]),i].T, cmap = 'RdYlGn', extent = [ax_extreme[0],ax_extreme[4],ax_extreme[1],ax_extreme[5]],
						alpha = alpha, origin = 'lower', interpolation='nearest')
					plt.axis('off')
				if Sagital == 0:
					ax2 = fig.add_subplot(gs0[2-Axial*2:4-Axial*2:2,j*2:j*2+2])
					plt.imshow(anat[round(anat.shape[0]*n[j]),:,:].T[:,::-1], cmap = 'Greys_r', 
						origin = 'lower', interpolation = 'nearest', extent = [sag_extreme[2],sag_extreme[6],sag_extreme[3],sag_extreme[7]])
					plt.imshow(overlay[round(overlay.shape[0]*n[j]),:,:,i].T[:,::-1], cmap = 'RdYlGn', extent = [sag_extreme[0],sag_extreme[4],sag_extreme[1],sag_extreme[5]],
						alpha = alpha, origin = 'lower', interpolation='nearest')
					plt.axis('off')
				if Coronal == 0:
					ax3 = fig.add_subplot(gs0[4-(Axial+Sagital)*2:6-(Axial+Sagital)*2:2,j*2:j*2+2])
					plt.imshow(anat[:,round(anat.shape[1]*n[j]),:].T, cmap = 'Greys_r', 
						origin = 'lower', interpolation = 'nearest', extent = [cor_extreme[2],cor_extreme[6],cor_extreme[3],cor_extreme[7]])
					plt.imshow(overlay[:,round(overlay.shape[1]*n[j]),:,i].T, cmap = 'RdYlGn', extent = [cor_extreme[0],cor_extreme[4],cor_extreme[1],cor_extreme[5]],
						alpha = alpha, origin = 'lower', interpolation='nearest')
					plt.axis('off')
			l = l + 1
		else:
			for j in range(len(n)):
				if Axial == 0:
					ax1 = fig.add_subplot(gs0[0:2,j*2:j*2+2])
					plt.imshow(overlay[:,:,round(overlay.shape[2]*n[j]),i].T, cmap = 'Greys_r', extent = [ax_extreme[0],ax_extreme[4],ax_extreme[1],ax_extreme[5]],
						origin = 'lower', vmin = np.amin(overlay[:,:,round(overlay.shape[2]*.5),i])/5, 
						vmax = np.amax(overlay[:,:,round(overlay.shape[2]*.5),i])/5)
					plt.axis('off')
				if Sagital == 0:
					ax2 = fig.add_subplot(gs0[2-Axial*2:4-Axial*2,j*2:j*2+2])
					plt.imshow(overlay[round(overlay.shape[0]*n[j]),:,:,i].T, cmap = 'Greys_r', extent = [sag_extreme[0],sag_extreme[4],sag_extreme[1],sag_extreme[5]],
						origin = 'lower', vmin = np.amin(overlay[round(overlay.shape[0]*.5),:,:,i])/5, 
						vmax = np.amax(overlay[round(overlay.shape[0]*.5),:,:,i])/5)
					plt.axis('off')
				if Coronal == 0:
					ax3 = fig.add_subplot(gs0[4-(Axial+Sagital)*2:6-(Axial+Sagital)*2,j*2:j*2+2])
					plt.imshow(overlay[:,round(overlay.shape[1]*n[j]),:,i].T, cmap = 'Greys_r', extent = [cor_extreme[0],cor_extreme[4],cor_extreme[1],cor_extreme[5]],
						origin = 'lower', vmin = np.amin(overlay[:,round(overlay.shape[1]*.5),:,i])/5, 
						vmax = np.amax(overlay[:,round(overlay.shape[1]*.5),:,i])/5)
					plt.axis('off')

		if series != '':
		 	ax1 = fig.add_subplot(gs0[6-(Axial + Sagital + Coronal)*2,0:18])
			time_series = np.loadtxt(series)
		 	plt.plot(np.arange(time_series.shape[0]),time_series[:,i])
		gs0.tight_layout(fig, w_pad = -2.3, h_pad = -1)

		N = str(i)
		while len(N) < len(str(overlay.shape[3])):
			N = '0'+N
		plt.savefig('Component_'+N)
		plt.close()

"""
Collects data from the given data sets.
"""
def collect_data(anatomical, overlay, threshold_map):
	anatomical = ni.load(anatomical)
	overlay = ni.load(overlay)
	threshold = ni.load(threshold_map)
	anat = anatomical.get_data()
	overlay = overlay.get_data()
	threshold_data = threshold.get_data()
	anat_hdr = anatomical.get_header()
	overlay_hdr = overlay.get_header()
	return(anat, overlay, threshold_data, anat_hdr, overlay_hdr)

def tsnr(tsoc,medn):
	medn_data = ni.load(medn).get_data()
	tsoc_data = ni.load(tsoc).get_data()
	medn_mean = medn_data.mean(-1)
	medn_std = medn_data.std(-1)
	medn_tsnr = medn_mean/medn_std
	tsoc_mean = tsoc_data.mean(-1)
	tsoc_std = tsoc_data.std(-1)
	tsoc_tsnr = tsoc_mean/tsoc_std

	frac = medn_tsnr/tsoc_tsnr
	tsnr = mask(image = medn_tsnr, axis = (1,0))
	tsnr_frac = mask(image = frac, axis = (1,0))
	
	tsnr[tsnr == 0] = np.nan
	fig = plt.figure(figsize = (3.2*5,6))
	gs0 = gridspec.GridSpec(2,21)
	for i in range(1,10):
		ax1 = fig.add_subplot(gs0[0:2,i*2:i*2+2])
		plt.imshow(tsnr[:,::-1,round(i*.1*tsnr.shape[2])].T)
		plt.axis('off')
	ax1 = fig.add_subplot(gs0[0:2,20])
	plt.axis('off')
	plt.colorbar(aspect = 30)
	plt.show()
	# plt.savefig('medn_tsnr')

	tsnr_frac[tsnr_frac == 0] = np.nan
	fig = plt.figure(figsize = (3.2*5,6))
	gs0 = gridspec.GridSpec(2,21)
	import ipdb
	#ipdb.set_trace()
	for i in range(1,10):
		ax2 = fig.add_subplot(gs0[0:2,i*2:i*2+2])
		plt.imshow((tsnr_frac)[:,::-1,round(i*.1*tsnr_frac.shape[2])].T)
		plt.axis('off')
	ax2 = fig.add_subplot(gs0[0:2,20])
	plt.axis('off')
	plt.colorbar(aspect = 30)
	plt.show()
	# plt.savefig('tsnr_ratio')
def mask(image,axis):
	im_mask = np.zeros(image.shape)
	image[np.isnan(image)] = 0
	im_mask[image != 0] = 1
	im_z_slice = im_mask.sum(axis = axis)
	return image[:,:,im_z_slice > 0]





